# Handle generation of GRAAL-compatible contact maps from fastq files
import os
import time
from os.path import join
import hicstuff.digest as hcd
import hicstuff.iteralign as hci
import hicstuff.filter as hcf
from scipy.sparse import csr_matrix

def align_reads(reads, genome, out_sam, tmp_dir=None, threads=1, minimap2=False, iterative=False):
    """
    Select and call correct alignment method and generate logs accordingly.

    Parameters
    ----------
    reads : str
        Path to the fastq file with Hi-C reads.
    genome : str
        Path to the genome in fasta format
    out_sam : str
        Path to the output SAM file containing mapped Hi-C reads.
    tmp_dir : str
        Path where temporary files are stored.
    threads : int
        Number of threads to run alignments in parallel.
    aligner : bool
        Use minimap2 instead of bowtie2.
    iterative : bool
        Wether to use the iterative mapping procedure (truncating reads and
        extending iteratively)
    """
    if tmp_dir is None:
        tmp_dir = os.getcwd()
    
    if iterative:
        temp_directory = hci.generate_temp_dir(tmp_dir)
        hci.iterative_align(reads, genome, )


def merge_sam(sam1, sam2, out_pairs, min_qual=30):
    """
    Make a 2D BED file from two Hi-C fastq files. The Hi-C mates are matched
    by read identifier. Pairs where at least one reads maps with MAPQ below 
    min_qual threshold are discarded.

    Parameters
    ----------
    sam1 : str
        Path to the SAM file with aligned Hi-C reads.
    sam2 : str
        Path to the SAM file with aligned Hi-C reads.
    out_pairs : str
        Path to the output tab-separated 2D BED file with columns 
        chr1 start1 end1 name1 strand1 chr2 start2 end2 name2 strand2
    """
    ...


def attribute_fragments(frags, pairs, indexed):
    """
    Match a restriction fragment to each read.

    Parameters
    ----------
    frags : str
        Path to a fragments file, as generated by the digest module.
    pairs : str
        Path to a 2D BED graph containing Hi-C read pairs.
    indexed : str
        Path where the indexed pairs (with fragment indices) will be written.
    """
    ...


def generate_matrix(pairs, mat):
    """Generate the matrix by counting the number of occurences of each
    combination of restriction fragments in a 2D BED file.

    Parameters
    ----------
    pairs : str
        Path to a Hi-C pairs file in 2D BED format.
    mat : str
        Path where the matrix will be written.
    """
    ...


def full_pipeline(
    input1,
    input2=None,
    genome,
    enzyme=5000,
    circular=False,
    out_dir=None,
    tmp_dir=None,
    plot=False,
    min_qual=30,
    min_size=0,
    threads=1,
    no_cleanup=False,
    iterative=False,
    filter_events=False,
    prefix=None,
    start_stage="fastq",
    bedgraph=False,
    minimap2=False
):
    """
    Run the whole hicstuff pipeline. Starting from fastq files and a genome to
    obtain a contact matrix.
    
    Parameters
    ----------
    input1 : str
        Path to the Hi-C reads in fastq format (forward), the aligned Hi-C reads
        in SAM format, or the pairs file, depending on the value of start_stage.
    reads2 : str
        Path to the Hi-C reads in fastq format (forward), the aligned Hi-C reads
        in SAM format, or None, depending on the value of start_stage.
    genome : str
        Path to the genome in fasta format.
    enzyme : int or str
        Name of the enzyme used for the digestion (e.g "DpnII"). If an integer
        is used instead, the fragment attribution will be done directly using a
        fixed chunk size.
    circular : bool
        Use if the genome is circular.
    out_dir : str or None
        Path where output files should be written. Current directory by default.
    tmp_dir : str or None
        Path where temporary files will be written. Creates a "tmp" folder in
        out_dir by default.
    plot : bool
        Whether plots should be generated at different steps of the pipeline.
        Plots are saved in a "plots" directory inside out_dir.
    min_qual : int
        Minimum mapping quality required to keep a pair of Hi-C reads.
    min_size : int
        Minimum fragment size required to keep a restriction fragment.
    threads : int
        Number of threads to use for parallel operations.
    no_cleanup : bool
        Whether temporary files should be deleted at the end of the pipeline.
    iterative : bool
        Use iterative mapping. Truncates and extends reads until unambiguous
        alignment.
    filter_events : bool
        Filter spurious or uninformative 3C events. Requires a restriction enzyme.
    prefix : str or None
        Choose a common name for output files instead of default GRAAL names.
    start_stage : str
        Step at which the pipeline should start. Can be "fastq", "sam" or "pairs".
    bedgraph : bool
        Use the cooler-compatible bedgraph2 format instead of GRAAL format when
        writing the matrix
    minimap2 : bool
        Use minimap2 instead of bowtie2 for read alignment.
    """
    stages = {"fastq": 0, "sam": 1, "pairs": 2}
    start_stage = stages[start_stage]

    if out_dir is None:
        out_dir = os.getcwd()
    if tmp_dir = None:
        tmp_dir = join(out_dir, "tmp")
    os.mkdir(out_dir)
    os.mkdir(tmp_dir)
    now = time.strftime("%Y%m%d%H%M%S")

    if prefix is None:
        log_file = open('w', join(out_dir, "hicstuff_" + now + ".log"))
    else:
        log_file = open('w', join(out_dir, prefix + now + ".log"))


    if start_stage == 0:
        reads1, reads2 = input1, input2
    elif start_stage == 1:
        sam1, sam2 = input1, input2
    elif start_stage == 2:
        pairs = input1
    
    if start_stage == 0:
        align_reads(reads1, fa, minimap2, "end1.sam", tmp_dir, threads, minimap2, iterative)
        align_reads(reads2, fa, "bt2", "end2.sam", tmp_dir, threads, minimap2, iterative)

    if start_stage < 2:
        merge_sam(sam1, sam2, pairs)
        attribute_fragments(frags, pairs, indexed)

    if filter_events:
        uncut_thr, loop_thr = hcf.get_thresholds()
        hcf.filter_events()

    # NOTE: hicstuff.digest module has an "intersect_to_sparse_matrix". Could
    # start from this and make it work with pairs files.
    generate_matrix(pairs)

